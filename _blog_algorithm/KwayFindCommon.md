---
layout: default
title: KwayFindCommon
narrow: true
---
- 输入是 `k` 个已经排好序的数组。
    - 目标是找到那些在所有这 `k` 个数组里都出现的数字。

- Method1:
- 首先，公共元素的集合一定不会大于任意一个数组的集合
- 因此，我们取第一个数组作为”潜在的公共元素集合“数组res，对第二个数组的元素进行扫描，获取”真正的公共元素“common
- 令res = common, 再对第三个数组的元素进行扫描，直到最后一个数组
- res即为最终结果
***
- Method2: k-way merge (和上面方法的时空间复杂度类似，method2还多了一个Logk)
- **算法思路：**    
    - **数据结构：** 使用一个最小堆（Min-Heap）和一个变量来记录当前堆中元素的最大值
    - **堆中存储：** 堆中存储 `k` 个元素，每个元素分别来自 `k` 个数组中当前被“指针”指向的那个元素。通常，堆中存储的节点会包含元素的值、它来自哪个数组的索引，以及它在该数组中的索引。
    - **初始化：** 将每个数组的第一个元素放入最小堆中，并维护这 `k` 个元素中的最大值 `max_element_in_heap`。
- **核心步骤（循环进行，直到某个数组被遍历完）：**
    - **获取堆顶元素：** 查看最小堆的堆顶元素 `min_in_heap = min_heap.peek()`。这是当前所有数组中被指向的 `k` 个元素里最小的那个。
    - **Key point**
        - **情况 1: `min_in_heap.value == max_element_in_heap`**
            - 这意味着当前堆中所有 `k` 个元素的值都相等（因为最小的和最大的相等，那么中间的所有元素也都必须和它们相等）。
            - 既然这 `k` 个元素都相等，说明这个值是所有 `k` 个数组都共同拥有的元素。
            - 将这个共同元素添加到结果列表中。
            - 然后，将这 `k` 个元素全部从堆中弹出，并从它们各自的数组中取下一个元素放入堆中。更新 `max_element_in_heap`。
        - **情况 2: `min_in_heap.value < max_element_in_heap`**
            - 这意味着堆顶的元素（即当前 `k` 个元素中最小的那个）严格小于堆中存在的最大元素。
            - 因此，这个 `min_in_heap.value` 不可能是所有 `k` 个数组的共同元素（因为它至少比其中一个数组当前指向的元素要小）。
            - 所以，我们应该“放弃”这个最小的元素。将其从堆中弹出，并从它所属的那个数组中取出下一个元素放入堆中。更新 `max_element_in_heap`。
- **终止条件：**
    - 当任何一个数组的元素被遍历完毕（即对应的指针超出了数组边界），算法就停止，因为不可能再找到所有 `k` 个数组都共同拥有的元素了。