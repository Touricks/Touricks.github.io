---
layout: default
title: DP-Algorithm
narrow: true
---
```table-of-contents

```

## 综述

### 复习课

```
induction rule: 当前dp[i]是怎么通过比i小的那些数据得到的 -> linear scan回头看，过例子填表

case 1: i 和 i - 1存在什么关系 -> 看一个，常发生于sub-array

case 2：切割问题(子段)，切的这一刀到底在哪，分出的左大段右小段，

case 3: 所有比i小的那些j需要满足什么条件，能够贡献到dp[i] -> 看所有

case 4(2d): input[i][j]是什么状态 -> 回头看三个大哥dp[i-1][j-1],dp[i-1][j],dp[i][j-1]

result：dp[len - 1] or globalMax or anything 技巧如果你一直都在继承，globalMax == dp[len - 1]，但凡你有reset动作，都要选择globalMax

一直在继承 -> 如果只关心数值，一样
		  -> 如果关心状态，dp[len - 1]**
```

### DP 问题定义和分类

High Level: 常见于求的是一个数字（min/max/boolean）,当前状态严格依赖于前面的结果

| 步骤               | 提示                                                                            | 通用做法                                                      |
| ------------------ | ------------------------------------------------------------------------------- | ------------------------------------------------------------- |
| **明确目标量类型** | 常见求 min / max / boolean                                                      | 写出要优化/判定的量：最少步、最大和、可不可行…                |
| **定义**           | **题目的什么**放进来；注意一定要以 _index_ 结束                                 | `dp[i] = 以 i 结尾的 … 的最优值`                              |
| base case          | dp[0] / dp[1]                                                                   | 哪些 i 不再依赖更小 i？<br>直接填常数/0/∞/false               |
| dp 数组维度        | 若在基础 state i 之外还要一段容量表示操作次数/物品数量/容器容量 ⇒ 维度+1 或更多 | 一维：`dp[i]`二维：`dp[i][c]` (i = 位置, c = 资源)…           |
| 选填表顺序/结果    | 先左后右 or 全局最大                                                            | 使得所依赖的 j 在 i 之前已算好；答案是 `dp[n-1]` 或 `max(dp)` |

---

- 常见数据形态
- **一维序列**（绳子、字符串…）
  - 元素权重相同 → 线性扫描 + 回看前缀/前一段
    - 例：最长升子串、剪绳子、最长回文子串
  - 权重不同 → 中心切分枚举 `k`
    - 例：合并石子、矩阵连乘最优括号
- **二维/双序列**
  - 矩阵路径、LCS/LIS、编辑距离
- **区间 DP**
  - `dp[l][r]` 枚举中点 `k`：回文切割、戳气球
- **多维背包 / 状态压缩**
  - 额外维度存剩余容量、子集 bitmask

### DP 问题解题思路

Step1：state：需要设计几个维度？需要辅助数组吗？
Step2：Base Case
Step3：Induction Rule
给一个例子，画 dp array 的构建过程，用于表示当前`dp[i]`怎么通过比 i 小的数据得到的
Step4：Result 结果如何收集

| 决策         | 例题                                                                  | 说明                                 |
| ------------ | --------------------------------------------------------------------- | ------------------------------------ |
| **数组维度** | LIS → `dp[i]` 一维；LCS → `dp[i][j]` 二维；回文切割 → 区间 `dp[l][r]` | 维度＝唯一确定一个子问题需要的坐标数 |
| **遍历顺序** | LIS → `i` 从左到右；LCS → i, j 双 for；区间 DP → 先枚举区间长度       | 确保用到的子问题已在表中             |
| **辅助结构** | 硬币组合 → 可只用一维滚动；石子合并 → 预处理前缀和                    | 注意数组越界问题                     |

| 例题                     | 典型分支                                                                              | 递推                                                              |
| ------------------------ | ------------------------------------------------------------------------------------- | ----------------------------------------------------------------- |
| **0/1 背包**             | Case1：不选当前物品 Case2：选当前（前提 `wᵢ≤cap`）                                    | `dp[i][c] = max(dp[i-1][c], 1+dp[i-1][c-wᵢ])`                     |
| **最长公共子序列 (LCS)** | 如果 `s1[i]==s2[j]` ➜ "对角 +1"否则取上或左的较大                                     | `dp[i][j] = (match? dp[i-1][j-1]+1 : max(dp[i-1][j],dp[i][j-1]))` |
| **回文切割**             | 枚举中点 `k (i≤k<j)`：`dp[i][j]=min(dp[i][k]+dp[k+1][j]+1)`若 `s[i…j]` 本身已回文 → 0 | 需要 `O(n³)` 枚举 `k`                                             |

### DP 可用性判断

| 判断项                              | 可能的问法                   | 快速识别信号                                                    |
| ----------------------------------- | ---------------------------- | --------------------------------------------------------------- |
| **A. 最优性/可达性问法**            | "min / max / boolean"        | 题干含 _最短、最小、最大、能否_…                                |
| **B. 子问题可重叠**                 | "当前状态依赖前面的结果"     | 相同子区间/相同余量会被多条路径反复用到（如数组下标、背包容量） |
| **C. 有清晰的"前缀/后缀/子段"分界** | "一定要 **ending at index**" | 结果可以自然分割为"某个 index 之前的决策 + 本步决策"            |

**若 A+B+C 均满足 ⇒ 80% 概率可 DP；**  
若缺 C → 多半要用贪心 / 双指针；  
若缺 B → 子问题不重叠，深搜/分治更合适；  
若缺 A → 可能是构造、排序、并查集之类结构题。

| 缺少的条件                                          | 例题 & 题意                                                      | 为什么这条缺失？ → 不能 / 不值得 DP                                                                                                                                                                      | 常见替代解法                          |
| --------------------------------------------------- | ---------------------------------------------------------------- | -------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------- | ------------------------------------- |
| **A. 没有 min / max / boolean 这类"最优/可达"目标** | 列出一个字符串的所有排列                                         | - 要求的是**完整枚举**，既不是求最小/最大/可达，也没有计数；- 动态规划强调 **复用子结果** 去推"某种最优/判定/计数"——这里不存在"最优"；- 任何 DP 都得把 `n!` 个结果存表，成本与直接回溯相同，反而更麻烦。 | 经典 swap-swap                        |
| **B. 子问题不重叠**                                 | **"计算 n!（阶乘）"**                                            | - 递归公式 `f(n)=n·f(n-1)` 虽然看似"子问题"，但 **每个 n 只被用一次**；- 不存在多条路径反复需要 `f(k)`，所以记忆化 / DP 不会节省任何工作；                                                               | 递归或循环 **O(n)** 乘法即可          |
| **C. 无法用单一 index（或有限维）把状态彻底封闭**   | "会议室安排相关问题：给定若干区间，找能安放的最大互不重叠区间数" | - 若把区间按结束排序，用 `dp[i] = 以第 i 个区间结尾的最多场数` 可以在证明最优子结构后进行 DP，但是 DP 代码复杂度不如直接贪。下面给出 DP 解法链接。                                                       | 贪心 /DP（结束时间最早）TC O(n log n) |

- 会议室问题
  [meetingRoomProblem](/algorithmnotes/meetingRoomProblem.html)

## 使用前缀和和拍扁技巧的 DP

- 前缀和的最大用处永远是**以空间换时间**

### 多组前缀和问题

- 使用前缀和对行/列就行优先处理，使得通过 O（1）时间可以得到一个范围内所有值的和/积

- 求最长十字架的长度 [Longest Cross Of 1s](/algorithmnotes/Longest Cross Of 1s.html)
  - 对行或列预处理前缀和作为辅助数组，达到对每个方案可以 O（1）时间求得对应的 dp 值
- 求最长星型 X 的长度 [Longest X of 1s](/algorithmnotes/Longest X of 1s.html)
  - 对对角线预处理前缀和作为辅助数组
- 求最大子矩阵
  - [LargestSubmatrixSum](/algorithmnotes/LargestSubmatrixSum.html)

### 树上路径问题（Top-Down）

[树上路径问题(TopDown)](/algorithmnotes/(TopDown).html)

## 一维(线性)DP

- 左大段右小段，大段读表小段计算
- 切绳子
  - [Max Product Of Cutting Rope](/algorithmnotes/Max Product Of Cutting Rope.html)
  - 左大段右小段: 大段，是不用重新计算，读表格的方式获得的部分；小段是需要计算的部分
  - 注意是否需要**至少切一段**,可以通过默认值控制(dp[0])或者给较小值 hard code base case
  - 易错点：Base Case， Induction Rule（dp[i]代表至少切一段的最大值，但因为转移时可以在 index=i 之后切，因此如果不切 i 之前的绳子，dp[i]还是最优解吗?）
- 切字符串
  - [Dictionary WordI](/algorithmnotes/Dictionary WordI.html)
  - DP+hashset
- 最大子串和，返回左右边界
  - [LargestSubarraySum](/algorithmnotes/LargestSubarraySum.html)
  - 易错点：Base Case 的设计
- 跳格子
  - [Array Hopper I](/algorithmnotes/Array Hopper I.html)
  - [Array Hopper II](/algorithmnotes/Array Hopper II.html)
    - 从第一位跳到最后一位，是否存在方案/最小步数
- House Robber:
  - 环形数组的解题思路：特别处理是否取第一位，执行两次 dp
  - [HouseRobber](/algorithmnotes/HouseRobber.html)
- Longest Increasing Subsequence
  - 最长上升子序列，不需要数字连续，但要保持相对顺序
  - [LIS](/algorithmnotes/LIS.html)
- Largest Set of Points With Positive Slope
  - LIS 变式
  - 核心在于 LIS 的 index 和 value 分别代表了什么
  - 将 index 视为横坐标，value 视为纵坐标，则问题简化为：
    - 按照 index 排序后，value 的 LIS （是吗？）
  - [LongestSlope](/algorithmnotes/LongestSlope.html)
- Longest Common Subsequence
  - 最长公共子序列
  - **只要转移方程可能引用"空子问题"（即 i 或 j 减 1 后会越界），就应提前多开一行/列或一位作为哨兵来统一处理边界**
  - 相比于 LIS 问题，**LIS** 的最"浅"回溯就是 `j=0`，仍在数组范围内；而 LCS 的 induction rule 中，`i-1` 或 `j-1` 可以等于 **0** ⇒ 需要 `dp[0][⋅]` 与 `dp[⋅][0]`
  - [LCS](/algorithmnotes/LCS.html)

## 二维（线性）DP

- 编辑距离
  - [Edit Distance](/algorithmnotes/Edit Distance.html)
- 最大正方形
  - [LargestSquareOf1s](/algorithmnotes/LargestSquareOf1s.html)

## 树型 DP

### 树上路径问题

[树上路径问题(Bottomup)](/algorithmnotes/树上路径问题(Bottomup).html)

## 区间 DP

### 概述

- 常见模型

| 模型                                     | 关键转移                                                | 典型题                                     |
| ---------------------------------------- | ------------------------------------------------------- | ------------------------------------------ |
| **对称端点选择**（游戏 / 取石子 / 披萨） | 选左 or 右，剩下仍是区间                                | "Predict the Winner"、[pizzaPick](/algorithmnotes/pizzaPick.html)        |
| **断点划分**（矩阵链乘、石子合并）       | `dp[i][j] = min/max_{k∈(i,j)} dp[i][k]+dp[k+1][j]+cost` | 石子合并、区间乘法最小代价                 |
| **内部删除或扩展**（回文、括号消除）     | 删去或合并首尾 / 匹配对，再递归                         | 最长回文子串 deletions、括号匹配删最少字符 |

- 解题过程

| 步骤           | 思路                                                                                                                                     | 例题：Pizza Pick                                                                                                                                                                                                                              |
| -------------- | ---------------------------------------------------------------------------------------------------------------------------------------- | --------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------- |
| State          | 用一段区间 `[i, j]` 表示一个子问题；`dp[i][j]` 存储这段区间在某个**最优指标**（最大值、最小值、可行性等）下的结果。                      | `dp[i][j]` = 从第 `i` 块到第 `j` 块披萨里，**先手**最终能拿到的最大总和。                                                                                                                                                                     |
| Base case      | 最小区间（长度 1、2）直接算： 长度 1 → 只剩一个元素 长度 2 → 只剩两个元素，通常显式比较或累加                                            | - 长度 1：`dp[i][i] = value[i]`- 长度 2：`dp[i][i+1] = max(value[i], value[i+1])`                                                                                                                                                             |
| Induction Rule | 把 `[i, j]` 拆成 **更短的区间**；常见拆分方式： - 选左端 / 右端（对称两种） - 枚举一个断点 `k` 把区间分成两段 - 删掉某一段后剩余仍是区间 | 先手可选左或右：` take-left = value[i] + 剩余局面``take-right = value[j] + 剩余局面 `因为对手是"贪心拿大"，剩余局面要先模拟对手动作再轮到自己：`dp[i][j] = max(value[i] + dp[i+2][j] 或 dp[i+1][j-1], value[j] + dp[i+1][j-1] 或 dp[i][j-2])` |
| 更新顺序       | 由小到大按区间长度递推：`for len = 1 .. n` `for i = 0 .. n-len` `j = i+len-1`                                                            | 同样用"两层循环 + 长度"自底向上填表；也可用记忆化 DFS 自顶向下。                                                                                                                                                                              |
| Result         | 通常是 `dp[0][n-1]`                                                                                                                      | `dp[0][n-1]` 就是整条披萨带的最优得分。                                                                                                                                                                                                       |
| 时空间复杂度   | - **时间**：O(n²) (若每步常数分支)；需要枚举断点则 O(n³)- **空间**：O(n²)，可用滚动数组 / 对角线压缩                                     | 本题分支恒定 → **O(n²)** 时间，O(n²) 空间                                                                                                                                                                                                     |

### 例题

- Pizza Pick 第一类题型代表
  - 选左端或右端
  - 博弈论形区间 DP
  - [pizzaPick](/algorithmnotes/pizzaPick.html)
- Cut Wood 第二类题型代表
  - 枚举一个断点 k 把区间分成两段
  - 切点形区间 DP：`O(N^3)`
  - [CutWood](/algorithmnotes/CutWood.html)
- Minimum Insertion Step 第三类题型代表
  - 将一个字符串变为回文串需要的最小插入次数
  - `O(N^2)`
  - [MinimumInsertion](/algorithmnotes/MinimumInsertion.html)

## 状压 DP

### 概述

- 所谓状压, 就是**用一个整数（数字）精简地表示一个集合或一个组合的状态**，然后利用高效的位运算来处理原先复杂的集合操作。
- 如何判断一个题目是否可以使用状压 DP：

  - 1.  需要表示状态的"元素"数量必须比较小，小到可以被一个整数的二进制位所容纳
  - 例如：26 个字母，棋盘的行列状态（比如 8x8 棋盘，可以用 long（64 位）表示）、物品的选择（比如少于 20 个物品）、图的节点访问情况（节点数少于 20）等。

  - 2.  每个元素的状态应该是"开/关"类型的，方便与二进制的 `1/0` 对应
  - 例如，物品是否**被选中**，一个点是否**被访问过**， 一个位置是否**被放置了棋子**。

  - 3.  问题涉及集合操作：问题的核心逻辑可以抽象为集合的交、并、差等操作。位运算恰好能高效地模拟这些操作。
  - **位运算与集合操作的对应关系**：
    - `mask | (1 << k)`：向集合中**加入**元素 k。
    - `mask & (1 << k)`：**判断**元素 k 是否在集合中。
    - `mask & ~(1 << k)`：从集合中**删除**元素 k。
    - `mask1 & mask2`：求两个集合的**交集**。
    - `mask1 | mask2`：求两个集合的**并集**。

- 此时，我们就可以令`dp[mask]` 可以表示"当物品的选择状态为 `mask` 时可以获得的最大价值
- 例题 1：选两个单词，要求两个单词没有共同字符，求最大长度乘积

  - 26 个字母，完全可以用一个 `int` (32 位) 或 `long` (64 位) 表示。
  - 对于一个单词，一个字母要么**存在**，要么**不存在**。
  - 判断**交集**是否为空 (`&`)。
  - [LargestProductOfLength](/algorithmnotes/LargestProductOfLength.html)

- 易错点：在 Java、C++、C# 等主流语言中，加法运算符 `+` 的**优先级高于**位移运算符 `<<`
- 如果我们显式地修改 mask，如`res = res + 1<<(ch-'a');`，会发生问题，因为编译器实际上是这样解析代码的： `res = (res + 1) << (ch - 'a');`，从而造成 bug
- 设置二进制位的标准、高效且无歧义的方法是使用**按位或 `|`** 操作符。

### 二进制数模型操作技巧

- **`&` (按位与)**: **检测与提取大师**。常用于检查特定位是否为 1，或将某些位清零。
- **`|` (按位或)**: **设置与合并专家**。常用于将特定位置为 1，或合并两个状态。
- **`^` (按位异或)**: **反转与找不同奇才**。常用于反转某些位，或在数据中寻找差异。

* **`<<` (左移)**: 将一个数的所有二进制位**向左**移动指定的位数，右边空出的位用 0 填充。在数值上，左移一位相当于**乘以 2**。
* **`>>` (右移)**: 将一个数的所有二进制位**向右**移动指定的位数。这是一个**有符号**右移，如果原数是正数，左边补 0；如果是负数，左边补 1（以保持符号不变）。在数值上，右移一位相当于**除以 2**（向下取整）。

---

- `&` (按位与) — "检测与提取"大师
- 常见使用场景：

1.  **判断奇偶 (Checking for Even/Odd)**
    这是最经典的用法。一个数的二进制表示中，只有最低位（第 0 位）决定了它的奇偶性（奇数为 1，偶数为 0）。

    ```java
    if ((n & 1) == 0) {
        // n 是偶数
    } else {
        // n 是奇数
    }
    ```

    **解释**：`n & 1` 的结果只会保留 `n` 的最低位，其他位全部变为 0，所以能快速判断奇偶。

2.  **判断某一位是否为 1 (Checking a specific bit)**
    检查一个数的第 `k` 位是否为 1。

    ```java
    // 检查数字 num 的第 k 位是否为 1
    if ((num & (1 << k)) != 0) {
        // 第 k 位是 1
    }
    ```

    **解释**：`1 << k` 会创建一个只有第 `k` 位是 1 的掩码（如 `00100`）。`&` 运算后，如果结果不为 0，说明 `num` 在第 `k` 位上也是 1。

3.  **清零或提取特定位 (Clearing or Extracting Bits)**
    将一个数末尾的几位置为 0，或者只保留末尾几位。

    ```java
    // 只保留 num 的低8位 (提取)
    int lower8bits = num & 0b11111111; // 0b11111111 等于 255

    // 将 num 的低8位清零 (清零)
    int clearedNum = num & (~0b11111111); // ~ 是按位取反
    ```

---

- `|` (按位或) — "设置与合并"专家
- 常见使用场景：

1.  **将某一位设置为 1 (Setting a specific bit)**
    这是 `|` 最核心的用途，确保一个数的第 `k` 位变为 1，而不影响其他位。

    ```java
    // 将数字 num 的第 k 位置为 1
    num = num | (1 << k);
    // 或者简写为:
    num |= (1 << k);
    ```

    **解释**：`1 << k` 创建一个只有第 `k` 位是 1 的掩码。进行或运算后，`num` 的第 `k` 位一定会变成 1。

2.  **合并权限或状态 (Combining permissions/flags)**
    在系统编程中，常用不同的位代表不同的权限（读、写、执行等）。`|` 可以将多个权限合并到一个整数中。

    ```java
    final int READ_PERMISSION = 4;  // 二进制 100
    final int WRITE_PERMISSION = 2; // 二进制 010
    final int EXEC_PERMISSION = 1;  // 二进制 001

    // 赋予读和写的权限
    int permissions = READ_PERMISSION | WRITE_PERMISSION; // 结果为 6 (二进制 110)
    ```

---

- `^` (按位异或) — "反转与找不同"奇才
- 常见使用场景：

1.  **反转某一位的状态 (Toggling a bit)**
    将一个数的第 `k` 位进行反转（0 变 1，1 变 0），而不影响其他位。

    ```java
    // 反转数字 num 的第 k 位
    num = num ^ (1 << k);
    // 或者简写为:
    num ^= (1 << k);
    ```

    **解释**：如果 `num` 的第 `k` 位是 1，`1 ^ 1 = 0`。如果第 `k` 位是 0，`0 ^ 1 = 1`。

2.  **寻找只出现一次的数字 (Finding the unique number)**
    一个数组中，只有一个数字出现奇数次，其他都出现偶数次，用 `^` 可以快速找到这个数。

    ```java
    // nums = [2, 3, 4, 2, 3]
    int unique = 0;
    for (int n : nums) {
        unique ^= n;
    }
    // 最终 unique 的结果是 4
    ```

    **解释**：基于 `N ^ N = 0` 和 `N ^ 0 = N`。所有出现偶数次的数字两两异或后都变成了 0，最后只剩下那个出现奇数次的数字。

3.  **不使用临时变量交换两个数 (Swapping two numbers)**
    这是一个经典的编程技巧。

    ```java
    int a = 5;
    int b = 10;

    a = a ^ b;
    b = a ^ b; // 相当于 (a^b) ^ b = a
    a = a ^ b; // 相当于 (a^b) ^ a = b
    ```
