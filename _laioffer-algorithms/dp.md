## 综述

### DP 问题定义和分类

High Level: 常见于求的是一个数字（min/max/boolean）,当前状态严格依赖于前面的结果

| 步骤               | 提示                                                                            | 通用做法                                                      |
| ------------------ | ------------------------------------------------------------------------------- | ------------------------------------------------------------- |
| **明确目标量类型** | 常见求 min / max / boolean                                                      | 写出要优化/判定的量：最少步、最大和、可不可行…                |
| **定义**           | **题目的什么**放进来；注意一定要以 _index_ 结束                                 | `dp[i] = 以 i 结尾的 … 的最优值`                              |
| base case          | dp[0] / dp[1]                                                                   | 哪些 i 不再依赖更小 i？<br>直接填常数/0/∞/false               |
| dp 数组维度        | 若在基础 state i 之外还要一段容量表示操作次数/物品数量/容器容量 ⇒ 维度+1 或更多 | 一维：`dp[i]`二维：`dp[i][c]` (i = 位置, c = 资源)…           |
| 选填表顺序/结果    | 先左后右 or 全局最大                                                            | 使得所依赖的 j 在 i 之前已算好；答案是 `dp[n-1]` 或 `max(dp)` |

---

- 常见数据形态
- **一维序列**（绳子、字符串…）
  - 元素权重相同 → 线性扫描 + 回看前缀/前一段
    - 例：最长升子串、剪绳子、最长回文子串
  - 权重不同 → 中心切分枚举 `k`
    - 例：合并石子、矩阵连乘最优括号
- **二维/双序列**
  - 矩阵路径、LCS/LIS、编辑距离
- **区间 DP**
  - `dp[l][r]` 枚举中点 `k`：回文切割、戳气球
- **多维背包 / 状态压缩**
  - 额外维度存剩余容量、子集 bitmask

### DP 问题解题思路

Step1：需要设计几个维度？需要辅助数组吗？
Step2：Base Case
Step3：Induction Rule
Step4：Result 结果如何收集

| 决策         | 例题                                                                  | 说明                                 |
| ------------ | --------------------------------------------------------------------- | ------------------------------------ |
| **数组维度** | LIS → `dp[i]` 一维；LCS → `dp[i][j]` 二维；回文切割 → 区间 `dp[l][r]` | 维度＝唯一确定一个子问题需要的坐标数 |
| **遍历顺序** | LIS → `i` 从左到右；LCS → i, j 双 for；区间 DP → 先枚举区间长度       | 确保用到的子问题已在表中             |
| **辅助结构** | 硬币组合 → 可只用一维滚动；石子合并 → 预处理前缀和                    | 注意数组越界问题                     |

| 例题                     | 典型分支                                                                              | 递推                                                              |
| ------------------------ | ------------------------------------------------------------------------------------- | ----------------------------------------------------------------- |
| **0/1 背包**             | Case1：不选当前物品 Case2：选当前（前提 `wᵢ≤cap`）                                    | `dp[i][c] = max(dp[i-1][c], 1+dp[i-1][c-wᵢ])`                     |
| **最长公共子序列 (LCS)** | 如果 `s1[i]==s2[j]` ➜ "对角 +1"否则取上或左的较大                                     | `dp[i][j] = (match? dp[i-1][j-1]+1 : max(dp[i-1][j],dp[i][j-1]))` |
| **回文切割**             | 枚举中点 `k (i≤k<j)`：`dp[i][j]=min(dp[i][k]+dp[k+1][j]+1)`若 `s[i…j]` 本身已回文 → 0 | 需要 `O(n³)` 枚举 `k`                                             |

### DP 可用性判断

| 判断项                              | 可能的问法                   | 快速识别信号                                                    |
| ----------------------------------- | ---------------------------- | --------------------------------------------------------------- |
| **A. 最优性/可达性问法**            | "min / max / boolean"        | 题干含 _最短、最小、最大、能否_…                                |
| **B. 子问题可重叠**                 | "当前状态依赖前面的结果"     | 相同子区间/相同余量会被多条路径反复用到（如数组下标、背包容量） |
| **C. 有清晰的"前缀/后缀/子段"分界** | "一定要 **ending at index**" | 结果可以自然分割为"某个 index 之前的决策 + 本步决策"            |

**若 A+B+C 均满足 ⇒ 80% 概率可 DP；**  
若缺 C → 多半要用贪心 / 双指针；  
若缺 B → 子问题不重叠，深搜/分治更合适；  
若缺 A → 可能是构造、排序、并查集之类结构题。

| 缺少的条件                                          | 例题 & 题意                                                      | 为什么这条缺失？ → 不能 / 不值得 DP                                                                                                                                                                      | 常见替代解法                          |
| --------------------------------------------------- | ---------------------------------------------------------------- | -------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------- | ------------------------------------- |
| **A. 没有 min / max / boolean 这类"最优/可达"目标** | 列出一个字符串的所有排列                                         | - 要求的是**完整枚举**，既不是求最小/最大/可达，也没有计数；- 动态规划强调 **复用子结果** 去推"某种最优/判定/计数"——这里不存在"最优"；- 任何 DP 都得把 `n!` 个结果存表，成本与直接回溯相同，反而更麻烦。 | 经典 swap-swap                        |
| **B. 子问题不重叠**                                 | **"计算 n!（阶乘）"**                                            | - 递归公式 `f(n)=n·f(n-1)` 虽然看似"子问题"，但 **每个 n 只被用一次**；- 不存在多条路径反复需要 `f(k)`，所以记忆化 / DP 不会节省任何工作；                                                               | 递归或循环 **O(n)** 乘法即可          |
| **C. 无法用单一 index（或有限维）把状态彻底封闭**   | "会议室安排相关问题：给定若干区间，找能安放的最大互不重叠区间数" | - 若把区间按结束排序，用 `dp[i] = 以第 i 个区间结尾的最多场数` 可以在证明最优子结构后进行 DP，但是 DP 代码复杂度不如直接贪。下面给出 DP 解法链接。                                                       | 贪心 /DP（结束时间最早）TC O(n log n) |

[MeetingRoomsProblem](/algorithmn-notes/meetingroomsproblem.html)

## 使用前缀和和拍扁技巧的 DP

106. Largest SubMatrix Sum

## 一维(线性)DP

- 左大段右小段，大段读表小段计算
- 切绳子
  - [Max Product Of Cutting Rope](/algorithmn-notes/maxproductofcuttingrope.html)
  - 左大段右小段: 大段，是不用重新计算，读表格的方式获得的部分；小段是需要计算的部分
  - 注意是否需要**至少切一段**,可以通过默认值控制(dp[0])或者给较小值 hard code base case
- 切字符串
  - [Dictionary WordI](/algorithmn-notes/dictionarywordi.html)
- 最大子串和，返回左右边界
  - [LargestSubarraySum](/algorithmn-notes/largestsubarraysum.html)
- 跳格子
  - [Array Hopper I](/algorithmn-notes/arrayhopperi.html)
  - [Array Hopper II](/algorithmn-notes/arrayhopperii.html)
- 编辑距离
  - [Edit Distance](/algorithmn-notes/editdistance.html)
- 最大正方形
  - [LargestSquareOf1s](/algorithmn-notes/largestsquareof1s.html)

## 树型 DP

### 树上路径问题

![TreePathProblems](/algorithmn-notes/treepathproblems.html)

## 区间 DP

## 状压 DP
